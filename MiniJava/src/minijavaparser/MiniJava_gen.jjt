options
{
	LOOKAHEAD = 1; //we can use LOOKAHEAD=2, BUT THERE MAY BE PROBLEMS WITH THE	 "FORCE_LA_CHECK", WHICH SEEMS TO GIVE AN ERROR REGARDLESS THE USE OF THE LOOKAHEAD >1 OPTION
	FORCE_LA_CHECK = false;
	CHOICE_AMBIGUITY_CHECK = 2;
	OTHER_AMBIGUITY_CHECK = 1;
	DEBUG_PARSER = false;
	
	TRACK_TOKENS = true;
	TOKEN_EXTENDS = "progen.Entity";
	
	NODE_CLASS = "progen.ProgenNode";
	NODE_EXTENDS = "progen.Entity";

	MULTI = true;
	VISITOR = true;
	NODE_DEFAULT_VOID = true;
}

PARSER_BEGIN(MiniJava)
package minijavaparser; 

import java.io.*;
import minijavaparser.visitors.metadata.*;

public class MiniJava
{	
	public static void main(String args[]) 
	{
	    System.err.println("Reading from standard input...");
	    try 
	    {
	      	MiniJava p = new MiniJava(new FileInputStream(new File("./samples/test01.java")));
	    	ASTProgram root = p.Program();
	    	root.dump(">");
			System.out.println("Thank you.");
	    } 
	    catch (Exception e) 
	    {									      
			System.err.println("Oops.");
			System.err.println(e.getMessage());
			e.printStackTrace();
	    }
	}
}

PARSER_END(MiniJava)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN : /* KEYWORDS */
{
  <CLASS: "class">
| <PUBLIC: "public">
| <STATIC: "static">
| <VOID: "void">
| <MAIN: "main">
| <STRING: "String">
| <EXTENDS: "extends">
| <IF: "if">
| <ELSE: "else">
| <WHILE: "while">
| <PRINTLN: "System.out.println">
| <RETURN: "return">
| <INT: "int">
| <BOOLEAN: "boolean">
| <LENGTH: "length">
| <TRUE: "true">
| <FALSE: "false">
| <THIS: "this">
| <NEW: "new">
} 

TOKEN : /* IDENTIFIERS */
{
  < ID: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < INTEGER_LITERAL: (< DIGIT >)+ >
|
  < #LETTER: ["_","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
}

TOKEN : /* OPERATORS */
{
  < ADD: "+" >
| < SUB: "-" >
| < MUL: "*" >
| < DIV: "/" >
| < GT: ">" >
| < GE: ">=" >
| < LT: "<" >
| < LE: "<=" >
| < EQ: "==" >
| < NE: "!=" >
| < NOT: "!" >
| < AND: "&&" >
| < OR: "||" >
}

TOKEN : /* SEPARATORS */
{
  <LBRACKET: "[">
| <RBRACKET: "]"> 
| <LPAREN: "(">
| <RPAREN: ")">
| <LACCOLADE: "{">
| <RACCOLADE: "}">
| <COMMA: ",">
| <SEMICOLON: ";">
| <DOT: "." >
| <ATRIB: "=" >
}

TOKEN: //SPECIAL
{
  <NONE: ~[] >
}

ASTProgram Program() #Program:
{
  MClass declClass;
}
{
	MainClass() ( ClassDecl() )* <EOF>
  	{
  		return jjtThis; 
  	}
}

void MainClass() #MainClass:
{
  MClass thisClass = new MClass();
  Token name;
}
{ 
	< CLASS > name = < ID > "{"  MainFuncDecl() "}"
	{
	  	thisClass.declName = name.image;
		jjtThis.jjtSetValue(thisClass);
	}
}

void MainFuncDecl() #MainFuncDecl:
{
  MFunc thisFunc = new MFunc();
  MVar param = new MVar();
  Token name,type,args,retType;
}
{
	< PUBLIC > < STATIC > retType = < VOID > name = < MAIN > "(" type = < STRING > "[" "]" args = < ID > ")" "{"  Statement() "}"
	/*{ //nu cred ca aceste informatii sunt necesare, dar de ce nu? nu este 100% corect, cel mai probabil, dar e o idee
	    //args
	  	param.declName=args;
	  	param.declType=new MType();
	  	param.declType.declType = type;
	  	param.declType.isArray = true;
	  	//func name, declared returned type and class where was declared
	  	thisFunc.declName = name;
	  	thisFunc.declRetType = new MType();
	  	thisFunc.declRetType.declType = retType;
	  	thisFunc.parent=mainClass;
	  	//add args to list
	  	thisFunc.addParam(param);
	  	jjtThis.jjtSetValue(thisFunc);
	  	//add method to classes methods
	  	mainClass.addMethod(thisFunc);
	}*/
}

void  ClassDecl() #ClassDecl:
{
}
{
//  LOOKAHEAD(3)
//	< CLASS > < ID > [] "{" (VarDecl())*  (MethodDecl())* "}"
//| 	< CLASS > < ID > < EXTENDS > < ID > "{" (VarDecl())*  (MethodDecl())* "}"
	< CLASS > < ID > [< EXTENDS > < ID >] "{" (VarDecl())*  (MethodDecl())* "}"
}

void VarDecl() #VarDecl:
{
  MVar var = new MVar();
  MType declType;
  Token name;
}
{
	declType = Type() name = < ID > ";"
	{
		var.declName = name.image;
		var.declType = declType;

		jjtThis.jjtSetValue(var);
	}
}

void MethodDecl() #MethodDecl:
{
  MFunc thisFunc = new MFunc();
  Token name;
  MType retType;
}
{
	"public" retType = Type() name = < ID > "(" FormalList() ")" //original orice functie trebuie sa ia parametrii = > pt proiectul meu am schimbat sa pot avea si functii fara param
	"{" (LOOKAHEAD(2)VarDecl())* (Statement())* < RETURN > Exp() ";" "}"
	{
		thisFunc.declName = name.image;
		thisFunc.declRetType = retType;

		jjtThis.jjtSetValue(thisFunc);
	}
}

void FormalList()#FormalList:
{
  MType type;
  Token name;
}
{
	type = Type() name = < ID > (FormalRest())*
	{
	  	MVar param = new MVar();
	  	param.declType = type;
	  	param.declName = name.image;
	}
| 	< NONE >
}

void FormalRest()#FormalRest:
{
  MType type;
  Token name;
}
{
	< COMMA > type = Type() name = < ID >
	{
	  	MVar param = new MVar();
	  	param.declType = type;
	  	param.declName = name.image;

	}
}

MType Type()#VarType:
{
  MType declType = new MType();
  Token type;
}
{
  LOOKAHEAD(2)
	type = < INT > "[" "]" { declType.declType = type.kind; declType.isArray = true; return declType; }
| 	type = < INT > { declType.declType = type.kind; return declType; }
| 	type = < BOOLEAN > { declType.declType = type.kind; return declType; }
| 	type = < ID > { declType.declType = type.kind; declType.typeName = type.image; return declType; }
}

void Statement()#Statement:
{}
{
	"{" Statement() "}"
|	< IF > "(" Exp() ")" Statement() < ELSE > Statement()
| 	< WHILE > "(" Exp() ")" Statement()
|	< PRINTLN > "(" Exp() ")" ";"
|	< ID > ("[" Exp() "]")? "=" Exp() ";"
}

void Exp()#void: 
{}
{
   Cond()
}

void Cond() #void:
{ }
{
	OrCond()
}

void OrCond() #OrCond:
{}
{
	AndCond() (< OR > AndCond())*
}

void AndCond() #AndCond:
{ }
{
	LogFactor() (< AND > LogFactor())*
}

void LogFactor() #LogFactor:
{}
{
	< TRUE >
| 	< FALSE >
|   RelExp()
}

void RelExp() #RelExp:
{ }
{
	ArExp() (RelOp() ArExp())?

}

void RelOp()#AdOp:
{ }
{
	< LT >
| 	< LE >
| 	< GT >
| 	< GE >
| 	< EQ >
| 	< NE >
}

void ArExp()#ArExp:
{ }
{
	Term() (AdOp() Term())*

}

void AdOp()#AdOp:
{ }
{
	< ADD >
| 	< SUB >
}

void Term()#Term:
{ }
{
	Factor() (MulOp() Factor())*	
}

void MulOp()#MulOp:
{ }
{
	< MUL >
| 	< DIV >
}

void Factor()#Factor:
{ }
{
	Subfactor() (LOOKAHEAD(2) FactorP())*   //am primit eroare fara lookahead aici, desi am in FactorP lookahead oricum
}

void FactorP()#FactorRest:
{ }
{
  	LOOKAHEAD(2)
	"." < ID > "(" ExpList() ")"
| 	"." < LENGTH >
| 	"[" Exp() "]"
}
 
void Subfactor()#ExpFinal:
{Token t;}
{
  	t = < ID >
| 	t = < THIS >
| 	t = < INTEGER_LITERAL >
| 	LOOKAHEAD(2)
	< NEW > t = < INT > "[" Exp() "]"
| 	< NEW > t = < ID > "(" ")"
| 	"(" Exp() ")"
|   < NOT > Factor()
}

void ExpList()#ExpList:
{}
{
	Exp() ("," Exp())*
| 	< NONE >
}


/* grammar
1. gramatica implementata
    Program ::= MainClass ClassDecl*

  MainClass ::= class id { public static void main ( String [] id )
               { Statement }}

  ClassDecl ::= class id [extends id] { VarDecl* MethodDecl* }

    VarDecl ::= Type id ;

 MethodDecl ::= public Type id ( FormalList )
               { VarDecl* Statement* return Exp ;}

 FormalList ::= Type id FormalRest*
           	::=

 FormalRest ::=, Type id

       Type ::= int []
           	::= boolean
           	::= int
           	::= id

  Statement ::= { Statement* }
           	::= if ( Exp ) Statement else Statement
           	::= while ( Exp ) Statement
           	::= System.out.println ( Exp ) ;
           	::= id = Exp ;
           	::= id [ Exp ]= Exp ;

		Exp ::= Condition

  Condition ::= OrCond

	 OrCond ::= AndCond ("||" AndCond)*

 	AndCond ::= LogFactor ("&&" LogFactor)*

  LogFactor ::= RelExp | "true" | "false"

	 RelExp ::= ArExp [RelOp ArExp] 

	  RelOp ::= < | > | < = | >= | == | !=

	  ArExp ::= Term (AdOp Term)*

	   AdOp ::= "+" | "-"

	   Term ::= Factor (MulOp Factor)*

	  MulOp ::= "*" | "/"

	 Factor ::= AtFact Rest*
	 		::= INTEGER LITERAL //l-am pus in factor pt ca nu poate fi urmat de nimic, spre deosebire the this sau id

	   Rest ::= "." id "(" ExpList ")"
			::= "." "length"
			::= "[" Exp "]"

	 AtFact ::= id | this 
	 		::= "new" "int" "[" Exp " ]"
	  		::= "new" "id" "(" ")"
	 		::= "(" Exp ")"
			::= "!" Factor

	ExpList ::= Exp ("," Exp)*
           	::=    //epsilon


-------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. gramatica primita
   Program ::= MainClass ClassDecl*

 MainClass ::= class id { public static void main ( String [] id )
               { Statement }}

 ClassDecl ::= class id { VarDecl* MethodDecl* }
           ::= class id extends id { VarDecl* MethodDecl* }

   VarDecl ::= Type id ;

MethodDecl ::= public Type id ( FormalList )
               { VarDecl* Statement* return Exp ;}

FormalList ::= Type id FormalRest*
           ::=

FormalRest ::=, Type id

      Type ::= int []
           ::= boolean
           ::= int
           ::= id

 Statement ::= { Statement* }
           ::= if ( Exp ) Statement else Statement
           ::= while ( Exp ) Statement
           ::= System.out.println ( Exp ) ;
           ::= id = Exp ;
           ::= id [ Exp ]= Exp ;

       Exp - ::= Exp op Exp
           ::= Exp [ Exp ]
           ::= Exp . length
           ::= Exp . id ( ExpList )
           - ::= INTEGER LITERAL
           - ::= true
           - ::= false
           - ::= id
           - ::= this
           - ::= new int [ Exp ]
           - ::= new id ()
           - ::= ! Exp
           - ::= ( Exp )

   ExpList ::= Exp ExpRest*
           ::=

  ExpRest  ::=  ,Exp


-------------------------------------------------- expressions----------------------------------------------

Exp ::= Condition

Condition ::= LogExp | "!" LogExp

LogExp ::= LogExpTerm ("||" LogExpTerm)*

LogExpTerm ::= LogExpFactor ("&&" LogExpFactor)*

LogExpFactor ::= "(" LogExp ")" | RelExp | "true" | "false"

RelExp ::= ArExp RelOp ArExp | ArExp  - > ArExp (RelOp ArExp)*

RelOp ::= <  | > | < = | >= | == | !=

ArExp ::= ArExp + Term | ArExp - Term | Term   -> Term ([+|-] Term)*

Term ::= Term '*' Factor | Term '/' Factor | Factor -> Factor ([*|/] Factor)*

Factor ::= id | this | OpNew | "(" ArExp ")" | INTEGER LITERAL | Exp "." Exp "(" ExpList ")" | Exp "." "length" | Exp "[" Exp "]"

OpNew ::= "new" "int" "[" Exp " ]"
	  ::= "new" "id" "(" ")"
	  
   ExpList ::= Exp ExpRest*
           ::=

  ExpRest  ::=  ,Exp

simplificare:

- elimin Condition
"(" LogExp ")" si "(" ArExp ")" pot intra in conflict (explicat mai jos)
	exp - > cond - > logExp - > LegExpTerm - > LogExpFactor- > "(" LogExp ")" - > "(" LogExpTerm ")" - > "(" LogExpFactor ")" - > "(" RelExp ")" - > "(" ArExp ")" - > ...
	exp - > cond - > logExp - > LegExpTerm - > LogExpFactor- > RelExp -> ArExp - > Term - > Factor - > "(" ArExp ")" - > ...


LogTerm.'!'Cond() - > Term.'!'Term pentru ca genera o eroare de expandare ! x & y se putea expanda ca (!x) & y, dar si incorect !(x & y)

*/